"""
Git operations management module.

Phase 1.5: Added validation to ensure repo_path is a valid git repository.
"""

# src/git_manager.py

import subprocess
import os
from pathlib import Path
from .models import Task

class GitManager:
    """
    Manages Git operations and PR creation.

    Phase 1.5: Operates on target repository, not tool repository.
    """

    def __init__(self, repo_path: str = "."):
        """
        Initialize GitManager for target repository.

        Args:
            repo_path: Path to git repository (typically target_dir in Phase 1.5)

        Raises:
            ValueError: If repo_path is not a valid git repository
        """
        self.repo_path = Path(repo_path).resolve()

        # Validate it's a git repository
        git_dir = self.repo_path / ".git"
        if not git_dir.exists():
            raise ValueError(
                f"Not a git repository: {self.repo_path}\n"
                f"Fix: cd {self.repo_path} && git init"
            )

    def _run_git(self, *args) -> subprocess.CompletedProcess:
        """Run git command"""
        return subprocess.run(
            ["git", "-C", str(self.repo_path)] + list(args),
            capture_output=True,
            text=True,
            check=True
        )

    def create_branch(self, task: Task) -> str:
        """Create feature branch for task"""

        # Generate branch name
        branch_name = f"moderator-gear1/task-{task.id}"

        try:
            # Create and checkout branch
            self._run_git("checkout", "-b", branch_name)
            task.branch_name = branch_name
            return branch_name
        except subprocess.CalledProcessError as e:
            raise Exception(f"Failed to create branch: {e.stderr}")

    def commit_changes(self, task: Task, files: list[str]) -> None:
        """Commit generated files"""

        try:
            # Stage files (force add to bypass .gitignore for Gear 1)
            # Note: Gear 1 design flaw - artifacts in state/ are gitignored
            # but need to be committed. Fixed in Gear 2 with .moderator/ architecture.
            for file_path in files:
                self._run_git("add", "--force", file_path)

            # Create commit message
            message = self._format_commit_message(task)

            # Commit
            self._run_git("commit", "-m", message)

        except subprocess.CalledProcessError as e:
            raise Exception(f"Failed to commit: {e.stderr}")

    def push_branch(self, branch_name: str) -> None:
        """Push branch to remote"""

        try:
            # Push branch with --set-upstream
            self._run_git("push", "-u", "origin", branch_name)

        except subprocess.CalledProcessError as e:
            raise Exception(f"Failed to push branch: {e.stderr}")

    def _format_commit_message(self, task: Task) -> str:
        """Format structured commit message"""

        criteria_text = "\n".join(f"- {c}" for c in task.acceptance_criteria)

        return f"""feat: {task.description[:60]}

Task ID: {task.id}

Acceptance Criteria:
{criteria_text}

Generated by: Moderator Gear 1
"""

    def create_pr(self, task: Task, base_branch: str = "dev") -> tuple[str, int]:
        """
        Create pull request via GitHub CLI

        Args:
            task: Task object containing PR details
            base_branch: Base branch to merge into (default: "dev" for Gear 1)

        Note: Gear 1 uses "dev" branch to avoid polluting main.
              Gear 2 will use proper target repository architecture.
        """

        try:
            # Format PR body
            pr_body = self._format_pr_body(task)

            # Create PR using gh CLI with explicit base branch
            result = subprocess.run(
                ["gh", "pr", "create",
                 "--base", base_branch,
                 "--title", f"Task {task.id}: {task.description[:50]}",
                 "--body", pr_body],
                capture_output=True,
                text=True,
                check=True,
                cwd=self.repo_path
            )

            # Extract PR URL from output
            pr_url = result.stdout.strip()

            # Get PR number
            pr_number = int(pr_url.split('/')[-1])

            return pr_url, pr_number

        except subprocess.CalledProcessError as e:
            raise Exception(f"Failed to create PR: {e.stderr}")
        except FileNotFoundError:
            raise Exception("GitHub CLI (gh) not installed")

    def _format_pr_body(self, task: Task) -> str:
        """Format PR description"""

        criteria_checklist = "\n".join(
            f"- [x] {c}" for c in task.acceptance_criteria
        )

        files_list = "\n".join(
            f"- `{f}`" for f in task.files_generated
        )

        return f"""## Task Description
{task.description}

## Acceptance Criteria
{criteria_checklist}

## Files Generated
{files_list}

## Review Notes
- This PR was generated automatically by Moderator Gear 1
- Please review code quality and verify acceptance criteria
- Manual testing recommended before merge

---
Generated by: **Moderator Gear 1** ðŸ¤–
Task ID: `{task.id}`
"""