"""
State persistence and management module.

Phase 1.5: Updated to use .moderator/ directory structure in target repository.
"""

# src/state_manager.py

import json
import os
from pathlib import Path
from .models import ProjectState, WorkLogEntry

class StateManager:
    """
    Manages project state persistence in .moderator/ directory.

    Directory structure (created in target repository):
    <target>/.moderator/
    ├── state/
    │   └── project_{id}/
    │       ├── project.json
    │       ├── logs.jsonl
    │       └── agent_memory_{agent_id}.json  # Future: Gear 2
    ├── artifacts/
    │   └── task_{id}/
    │       └── generated/
    │           └── *.py
    ├── logs/
    │   └── session_{timestamp}.log
    ├── config.yaml              # Optional project-specific config
    └── .gitignore              # Auto-created to exclude workspace
    """

    def __init__(self, base_dir: str = "./.moderator/state"):
        """
        Initialize StateManager.

        Args:
            base_dir: Base directory for state (default: .moderator/state)
                     This should be set to <target>/.moderator/state by main.py

        Side Effects:
            - Creates .moderator/ directory structure
            - Creates .moderator/.gitignore if not exists
        """
        self.base_dir = Path(base_dir).resolve()  # Resolve to absolute path

        # Determine if we're using .moderator/ structure
        # base_dir will be either "./state" (Gear 1) or "./.moderator/state" (Gear 2)
        if ".moderator" in str(self.base_dir):
            # Phase 1.5: Initialize .moderator/ structure
            self.moderator_dir = self.base_dir.parent  # .moderator/
            self._initialize_moderator_directory()
        else:
            # Gear 1 compatibility: Just create state directory
            self.base_dir.mkdir(parents=True, exist_ok=True)

    def _initialize_moderator_directory(self):
        """
        Create .moderator/ directory structure and .gitignore.

        Creates:
        - .moderator/state/
        - .moderator/artifacts/
        - .moderator/logs/
        - .moderator/.gitignore (if not exists)

        .gitignore contents:
            # Moderator workspace - excluded from git
            state/
            artifacts/
            logs/

            # Optional: Commit project-specific config
            # !config.yaml
        """
        # Create subdirectories
        (self.moderator_dir / "state").mkdir(parents=True, exist_ok=True)
        (self.moderator_dir / "artifacts").mkdir(parents=True, exist_ok=True)
        (self.moderator_dir / "logs").mkdir(parents=True, exist_ok=True)

        # Create .gitignore to exclude workspace files
        gitignore_path = self.moderator_dir / ".gitignore"
        if not gitignore_path.exists():
            gitignore_content = """# Moderator workspace - excluded from git
# Generated by moderator automatically

state/
artifacts/
logs/

# Optional: Uncomment to commit project-specific config
# !config.yaml
"""
            with open(gitignore_path, 'w') as f:
                f.write(gitignore_content)

    def save_project(self, state: ProjectState) -> None:
        """Save project state to JSON file"""
        project_dir = self.base_dir / f"project_{state.project_id}"
        project_dir.mkdir(parents=True, exist_ok=True)

        state_file = project_dir / "project.json"
        with open(state_file, 'w') as f:
            json.dump(state.to_dict(), f, indent=2)

    def load_project(self, project_id: str) -> ProjectState | None:
        """Load project state from JSON file"""
        state_file = self.base_dir / f"project_{project_id}" / "project.json"

        if not state_file.exists():
            return None

        with open(state_file, 'r') as f:
            data = json.load(f)

        return ProjectState.from_dict(data)

    def append_log(self, project_id: str, entry: WorkLogEntry) -> None:
        """Append log entry to JSONL file"""
        project_dir = self.base_dir / f"project_{project_id}"
        project_dir.mkdir(parents=True, exist_ok=True)

        log_file = project_dir / "logs.jsonl"
        with open(log_file, 'a') as f:
            f.write(json.dumps(entry.to_dict()) + '\n')

    def get_artifacts_dir(self, project_id: str, task_id: str) -> Path:
        """
        Get directory for task artifacts.

        Phase 1.5: Returns <target>/.moderator/artifacts/task_{id}/generated/
        Gear 1: Returns <target>/state/project_{id}/artifacts/task_{id}/generated/

        Args:
            project_id: Project identifier
            task_id: Task identifier

        Returns:
            Path to artifacts directory for the task
        """
        if ".moderator" in str(self.base_dir):
            # Phase 1.5: artifacts live in .moderator/artifacts/
            artifacts_dir = (self.moderator_dir / "artifacts" /
                           f"task_{task_id}" / "generated")
        else:
            # Gear 1 compatibility: artifacts under project state
            artifacts_dir = (self.base_dir / f"project_{project_id}" /
                           "artifacts" / f"task_{task_id}" / "generated")

        artifacts_dir.mkdir(parents=True, exist_ok=True)
        return artifacts_dir

    def get_logs_dir(self) -> Path:
        """
        Get directory for session logs.

        Phase 1.5: Returns <target>/.moderator/logs/
        Gear 1: Returns <target>/state/ (no separate logs directory)

        Returns:
            Path to logs directory
        """
        if ".moderator" in str(self.base_dir):
            # Phase 1.5: logs live in .moderator/logs/
            logs_dir = self.moderator_dir / "logs"
        else:
            # Gear 1 compatibility: no separate logs dir, use state
            logs_dir = self.base_dir

        logs_dir.mkdir(parents=True, exist_ok=True)
        return logs_dir

        